# Реализация алгоритма сжатия JPEG
Данный проект представляет собой полную программную реализацию алгоритма сжатия изображений в формате JPEG. Код включает все основные этапы JPEG-кодирования: преобразование цветового пространства, дискретное косинусное преобразование, квантование, зигзаг-сканирование и энтропийное кодирование по Хаффману.
# Теоретическая основа
JPEG (Joint Photographic Experts Group) - стандарт сжатия изображений, основанный на особенностях человеческого восприятия. Алгоритм использует дискретное косинусное преобразование (DCT) для перевода изображения в частотную область с последующим отбрасыванием высокочастотных компонентов, менее заметных для человеческого глаза.
# Основные этапы обработки
1. Преобразование цветового пространства RGB → YCbCr\
Y = 0.299R + 0.587G + 0.114B (яркостная компонента)\
Cb = 128 - 0.168736R - 0.331264G + 0.5B (цветность синего)\
Cr = 128 + 0.5R - 0.418688G - 0.081312B (цветность красного)\
Человеческий глаз более чувствителен к изменениям яркости (Y), чем цветности (Cb, Cr), что позволяет сильнее сжимать цветностные компоненты.\
`def rgb_to_ycbcr(R: np.ndarray, G: np.ndarray, B: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]`
2. Прореживание цветности (Chroma Subsampling) 4:2:0\
Уменьшение разрешения цветностных компонентов Cb и Cr в 2 раза по горизонтали и вертикали. Каждый пиксель в уменьшенной компоненте представляет собой усреднение 4 пикселей исходного изображения. Сокращает объем цветностных данных в 4 раза.\
`def downsample(c: np.ndarray) -> np.ndarray`
3. Разбиение на блоки 8×8\
Изображение разделяется на непересекающиеся блоки 8×8 пикселей. DCT применяется независимо к каждому блоку.
`def split_into_8x8_blocks(Ycbcr: np.ndarray) -> List[np.ndarray]`
4. Дискретное косинусное преобразование (DCT)\
Прямое DCT-II преобразование:\
`def dct_2d_8x8_optimized(block: np.ndarray) -> np.ndarray`\
Математическая формула:\
`F(u,v) = ¼ × C(u) × C(v) × ΣΣ f(x,y) × cos((2x+1)uπ/16) × cos((2y+1)vπ/16)
где C(u) = 1/√2 если u=0, иначе 1`
5. Квантование\
Деление каждого DCT-коэффициента на соответствующий элемент матрицы квантования с последующим округлением до целого.\
Матрицы квантования:
- Luminance_quantization_table - для яркостной компоненты Y
- Chrominance_quantization_table - для цветностных компонент Cb, Cr\
Функция generate_quantization_matrix() регулирует степень сжатия через параметр качества (1-100)\
`def quantize(dct_coeffs: np.ndarray, q_matrix: np.ndarray) -> np.ndarray`

6. Зигзаг-сканирование\
Коэффициенты читаются в порядке увеличения частоты, что группирует нулевые (высокочастотные) коэффициенты в конце последовательности\
`def zigzag_scan_fast(quantized: np.ndarray) -> np.ndarray`

7. Энтропийное кодирование\
Разностное кодирование DC-коэффициентов. DC-коэффициенты (постоянная составляющая) кодируются как разности между соседними блоками.\
`def dc_difference(coeffs: np.ndarray) -> None`

Кодирование AC-коэффициентов. AC-коэффициенты кодируются парами (количество нулей, размер значения) с использованием RLE.\
`def rle_encode_ac(num: int, rle_str: List[int], zero_count: int, EOB: bool) -> bool`

Кодирование Хаффмана. Используются стандартные JPEG таблицы Хаффмана:
- Luminance_DC_differences, Luminance_AC - для яркостной компоненты
- Chrominance_DC_differences, Chrominance_AC - для цветностных компонент\
`def HA_encode(data: List[int], DC_differences: List[str], AC: List[List[str]]) -> str`

# Таблицы Хаффмана
Проект включает полный набор стандартных JPEG таблиц Хаффмана:
- DC-таблицы: Кодируют категорию разности DC-коэффициентов (0-11)
- AC-таблицы: Двумерные массивы 16×10 для кодирования пар (run, size)

# Матрицы квантования
Стандартные матрицы для качества 50, масштабируемые в зависимости от требуемого уровня сжатия.

# Требования
Python 3.7+

NumPy

# Входные данные
- RAW изображение в формате RGB (файл color.raw)
- Разрешение 800×600 пикселей
- 24 бита на пиксель (по 8 бит на канал)

# Текущие ограничения
- Поддерживается только формат 4:2:0
- Фиксированное разрешение 800×600
- Базовые таблицы Хаффмана без адаптации

Проект служит образовательной целью, показывая полный pipeline современного алгоритма сжатия изображений от теоретических основ до практической реализации.
